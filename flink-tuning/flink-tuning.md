# flink 从

## 第 9 章 状态编程
在 Flink 这样的分布式系统中，我们不仅需要定义出状态在任务并行时的处理方式，还需要考虑如何持久化保存、以便发生故障时正确地恢复。这就需要一套完整的管理机制来处理所有的状态。
本章将从状态的概念入手，详细介绍 Flink 中的状态分类、状态的使用、持久化及状态后端的配置。
### 9.1 Flink 中的状态
#### 9.1.1 有状态算子
在 Flink 中，算子任务可以分为无状态和有状态两种情况。

如图 9-2 所示为有状态算子的一般处理流程，具体步骤如下。
（1）算子任务接收到上游发来的数据；
（2）获取当前状态；
（3）根据业务逻辑进行计算，更新状态；
（4）得到计算结果，输出发送到下游任务。
#### 9.1.2 状态的管理
我们直接把它作为一个对象交给 JVM 就可以了。然而大数据的场景下，我们必须使用分布式架构来做扩展，在低延迟、高吞吐的基础上还要保证容错性
- 状态的访问权限
- 容错性，也就是故障后的恢复
- 分布式应用的横向扩展性
Flink 有一套完整的状态管理机制，将底层一些核心功能全部封装起来，包括状态的高效存储和访问、持久化保存和故障恢复，以及资源扩展时的调整
#### 9.1.3 状态的分类
1. 托管状态（Managed State）和原始状态（Raw State）
Flink 的状态有两种：托管状态（Managed State）和原始状态（Raw State）。
托管状态就是由 Flink 统一管理的，状态的存储访问、故障恢复和重组等一系列问题都由 Flink 实现，我们只要调接口就可以；
而原始状态则是自定义的，相当于就是开辟了一块内存，需要我们自己管理，实现状态的序列化和故障恢复。
托管状态是由 Flink 的运行时（Runtime）来托管的；在配置容错机制后，状态会自动持久化保存，并在发生故障时自动恢复。
当应用发生横向扩展时，状态也会自动地重组分配到所有的子任务实例上。对于具体的状态内容，Flink 也提供了值状态（ValueState）、列表状态（ListState）、映射状态（MapState）、聚合状态（AggregateState）等多种结构，内部支持各种数据类型。聚合、窗口等算子中内置的状态，就都是托管状态；我们也可以在富函数类（RichFunction）中通过上下文来自定义状态，这些也都是托管状态
2. 算子状态（Operator State）和按键分区状态（Keyed State）
（1）算子状态（Operator State）
状态作用范围限定为当前的算子任务实例，也就是只对当前并行子任务实例有效
（2）按键分区状态（Keyed State）
状态是根据输入流中定义的键（key）来维护和访问的，所以只能定义在按键分区流（KeyedStream）中，也就 keyBy 之后才可以使用

